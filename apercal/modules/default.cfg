[INITIAL]
fluxcal = ''                                        # Flux calibrator dataset, e.g. '3C295.MS'
polcal = ''                                         # Polarised calibrator dataset, e.g. '3C286.MS'
target = ''                                         # Target dataset, e.g. 'LH_WSRT.MS'
basedir = ''                                        # Base directory for your data reduction, e.g '/data/adebahr/apertif/LH_WSRT/'
beam = '00'                                         # Beam number to work on for SELFCAL, CONTINUUM, LINE and POLARISATIOn module, e.g. '00'
rawsubdir = 'raw'                                   # Sub-directory for raw datasets, e.g. 'raw'
crosscalsubdir = 'crosscal'                         # Sub-directory for cross calibration, e.g. 'crosscal'
selfcalsubdir = 'selfcal'                           # Sub-directory for self calibration, e.g. 'selfcal'
linesubdir = 'line'                                 # Sub-directory for line imaging, e.g. 'line'
contsubdir = 'continuum'                            # Sub-directory for continuum imaging, e.g. 'continuum'
polsubdir = 'polarisation'                          # Sub-directory for polarisation imaging, e.g. 'polarisation'
mossubdir = 'mosaics'                               # Sub-directory for masaicking, e.g. 'mosaics'
transfersubdir = 'transfer'                         # Sub-directory for the transfer of the final (u,v)-datasets, e.g. 'transfer'
subdirification = True                              # assume data is in /basedir/beamnum/rawsubdir/fluxcal format

[PREPARE]
prepare_date = None                                 # Date of the observation, format: YYMMDD, e.g. '180817'
prepare_obsnum_fluxcal = None                       # Observation number of the flux calibrator, format: NNN, e.g. '001'
prepare_obsnum_polcal = None                        # Observation number of the polarised calibrator, format: NNN, e.g. '002'
prepare_obsnum_target = None                        # Observation number of the target, format: NNN, e.g. '003'
prepare_target_beams = None                         # Target beam numbers to copy, format: 'all' for all beams, '' for no target, and 'NN,MM,...' for certain beam numbers, e.g. '00,01'
prepare_bypass_alta = False                         # Set to true if you don't want to fetch data from the ALTA archive

[PREFLAG]
preflag_shadow = True                               # Flag all datasets for shadowed antennas
preflag_edges = True                                # Flag subband egdes for all datasets
preflag_ghosts = True                               # Flag ghost channels for all datasets
preflag_manualflag = True                           # Run the manualflag options
preflag_manualflag_fluxcal = True                   # Run manualflag options for the flux calibrator
preflag_manualflag_polcal = True                    # Run manualflag options for the polarised calibrator
preflag_manualflag_target = True                    # Run manualflag options for the target beams
preflag_manualflag_targetbeams = 'all'              # Targetbeams to flag, options: 'all' or '00,01,02'
preflag_manualflag_auto = True                      # Flag auto-correlations
preflag_manualflag_antenna = ''                     # Antennas to flag, e.g. 'RT2,RT3,RT4'
preflag_manualflag_corr = ''                        # Correlations to flag, e.g. 'XX,YX'
preflag_manualflag_baseline = ''                    # Flag certai baselines, e.g. 'RT2&RT3,RT5&RT6'
preflag_manualflag_channel = ''                     # Channels or channel ranges to flag, e.g. '0~3054;10977~16384'
preflag_manualflag_time = ''                        # Time range to flag, e.g. '09:14:0~09:54:0'
preflag_manualflag_clipzeros = False                # Flags all Zero-valued data (done by default AOFlagger strategies as well)
preflag_aoflagger = True                            # Run the aoflagger step
preflag_aoflagger_bandpass = True                   # Derive a preliminary bandpass for AOFlagging
preflag_aoflagger_fluxcal = True                    # AOFlag the flux calibrator
preflag_aoflagger_polcal = True                     # AOFlag the polarised calibrator
preflag_aoflagger_target = True                     # AOFlag the target beams
preflag_aoflagger_targetbeams = 'all'               # Targetbeams to flag, options: 'all' or '00,01,02'
preflag_aoflagger_fluxcalstrat = 'fluxcal.rfis'     # Flagging strategy for the flux calibrator
preflag_aoflagger_polcalstrat = 'polcal.rfis'       # Flagging strategy for the polarised calibrator
preflag_aoflagger_targetstrat = 'target.rfis'       # Flagging strategy for the target beams

[CROSSCAL]
crosscal_refant = 'RT2'                             # Reference antenna used through all cross calibration steps
crosscal_tec = False                                # TEC corrections for all datasets
crosscal_bandpass = True                            # Bandpass correction from the flux calibrator
crosscal_gains = True                               # Gain and flux corrections for the flux calibrator
crosscal_global_delay = True                        # Global delay corrections
crosscal_crosshand_delay = True                     # Cross-hand delay corrections
crosscal_leakage = True                             # Polarisation leakage corrections
crosscal_polarisation_angle = True                  # Polarisation angle corrections
crosscal_transfer_to_cal = True                     # Transfer corrections to calibrators
crosscal_transfer_to_target = True                  # Transfer corrections to the target fields
crosscal_transfer_to_target_targetbeams = 'all'     # Targetbeams to transger the solutions to, options: 'all' or '00,01,02'

[CONVERT]
convert_fluxcal = True                              # Convert the flux calibrator dataset
convert_polcal = True                               # Convert the polarised calibrator dataset
convert_target = True                               # Convert the target beam dataset
convert_targetbeams = 'all'                         # Targetbeams to convert, options: 'all' or '00,01,02'
convert_removeuvfits = True                         # Remove the UVFITS files

[SELFCAL]
selfcal_image_imsize = 3073                         # Image size in pixels
selfcal_image_cellsize = 4                          # Pixel size in arcseconds
selfcal_refant = '1'                                # Reference antenna used for self-calibration, MIRIAD numbering here
selfcal_average = True                              # Average the data to one channel per subband for self-calibration
selfcal_flagline = True                             # Flag residual RFI/HI emission for self-calibration and continuum imaging
selfcal_flagline_sigma = 0.5                        # Sensitivity parameter to flag RFI/HI emission
selfcal_parametric = True                           # Do parametric self-calibration
selfcal_parametric_skymodel_radius = 0.5            # Radius from the pointing centre in degrees until which sources are considered
selfcal_parametric_skymodel_cutoff = 0.8            # Cutoff for the appaerant flux in the skymodel to use sources (1.0 = all sources in catalogues)
selfcal_parametric_skymodel_distance = 30           # Distance between NVSS/FIRST and WENSS sources in arcseconds to count as the same source
selfcal_parametric_solint = 'auto'                  # Time solution interval in minutes or 'auto' for automatic calculation
selfcal_parametric_uvmin = 0.5                      # minimum u,v-limit in klambda
selfcal_parametric_uvmax = 1000                     # maximum u,v-limit in klambda
selfcal_parametric_amp = False                      # Parametric amplitude calibration
selfcal_parametric_nfbin = 16                       # Number of solution intervals over frequency for parametric calibration
selfcal_phase = True                                # Do the standard iterative self-calibration
selfcal_phase_majorcycle = 3                        # Maximum number of major cycles
selfcal_phase_majorcycle_function = 'power'         # Type of function to decrease threshold for major cycles, possible values: 'power'
selfcal_phase_minorcycle = 3                        # Maximum number of minor cycles within each major cycle
selfcal_phase_minorcycle_function = 'square'        # Type of function to decrease threshold for minor cycles, possible values: 'square', 'power', 'linear'
selfcal_phase_c0 = 10.0                             # c0 parameter to calculate noise DR with (c0 + minor_cycle * c0) * (major_cycle + 1)
selfcal_phase_c1 = 5.0                              # c1 parameter for clean threshold with mask_threshold / c1
selfcal_phase_drinit = 30                           # drinit parmeter to calculate dynamcic range limits in major cycles with drinit * np.power(dr0, major cycle)
selfcal_phase_dr0 = 2.0                             # dr0 parameter to calculate dynamcic range limits in major cycles with drinit * np.power(dr0, major cycle)
selfcal_phase_mindr = 5.0                           # minimum dynamic range for masking if calculated thresholds are lower
selfcal_phase_nsigma = 5                            # Factor to calculate theoretical noise threshold with nsigma * theoretical_noise
selfcal_phase_uvmin = [0.0,0.0,0.0]                 # Minimum u,v-range to use for phase self-calibration during major cylces, 1 value per cycle
selfcal_phase_uvmax = [3000,3000,3000]              # Maximum u,v-range to use for phase self-calibration during major cylces, 1 value per cycle
selfcal_phase_solint = 'auto'                       # Selfcal solution intervals for each major cycle as a list (e.g. [10,5,3]) or 'auto' for an automatic calculation
selfcal_phase_nfbin = 16                            # Number of frequency solution intervals
selfcal_phase_gaussianity = 1e-2                    # Gaussianity parameter for last residual image to verify phase calibration as good (see scipy.stats.normaltest)
selfcal_amp = True                                  # Do amplitude calibration, possible values True, False, 'auto'
selfcal_amp_auto_limit = 1.0                        # Threshold for the sum of clean components in Jy in the last model to set amp calibration True in auto mode
selfcal_amp_minorcycle = 3                          # Maximum number of additional minor cycles to create amplitude model
selfcal_amp_minorcycle_function = 'square'          # Type of function to decrease threshold for minor cycles, possible values: 'square', 'power', 'linear', should be the same as for phase calibration
selfcal_amp_c0 = 10.0                               # c0 parameter to calculate noise DR with (c0 + minor_cycle * c0) * (major_cycle + 1), should be the same as for phase calibration
selfcal_amp_c1 = 5.0                                # c1 parameter for clean threshold with mask_threshold / c1, should be the same as for phase calibration
selfcal_amp_drinit = 30                             # drinit parmeter to calculate dynamcic range limits in major cycles with drinit * np.power(dr0, major cycle), should be the same as for phase calibration
selfcal_amp_dr0 = 2.0                               # dr0 parameter to calculate dynamcic range limits in major cycles with drinit * np.power(dr0, major cycle), should be the same as for phase calibration
selfcal_amp_mindr = 5.0                             # minimum dynamic range for masking if calculated thresholds are lower, should be the same as for phase calibration
selfcal_amp_nsigma = 5                              # Factor to calculate theoretical noise threshold with nsigma * theoretical_noise, should be the same as for phase calibration
selfcal_amp_uvmin = 0.0                             # Minimum u,v-range to use for amplitude self-calibration during major cycles
selfcal_amp_uvmax = 3000                            # Maximum u,v-range to use for amplitude self-calibration during major cycles
selfcal_amp_solint = 'auto'                         # Selfcal solution interval for amplitude calibration (e.g. 20) or 'auto' for an automatic calculation
selfcal_amp_nfbin = 16                              # Number of solution intervals over frequency for amplitude calibration
selfcal_amp_gaussianity = 1e-2                      # Gaussianity parameter for amplitude residual image to verify amp calibration as good (see scipy.stats.normaltest)
selfcal_amp_ratio = 1.2                             # Ratio of the dirty image min, max, std before and after amplitude calibration to verify amplitude calibration as good

[CONTINUUM]
continuum_mfimage = True                            # Multi-frequency continuum imaging
continuum_mfimage_imsize = 3073                     # Image size in pixels
continuum_mfimage_cellsize = 4                      # Pixel size in arcseconds
continuum_mfimage_minorcycle = 5                    # Maximum number of cycles to clean the continuum image before automatic stop
continuum_mfimage_c1 = 5.0                          # c1 parameter for clean threshold with mask_threshold/c1
continuum_mfimage_drinc = 10.0                      # Increment for each iteration for the masking using max(residual map)/drinc
continuum_mfimage_mindr = 10.0                      # Minimum increase in dynamic range for the first cycle (in case calculated DR is lower)
continuum_mfimage_nsigma = 5                        # Factor to calculate theoretical noise threshold with nsigma * theoretical_noise
continuum_mf_gaussianity = 1e-2                     # Gaussianity parameter for amplitude residual image to verify amp calibration as good (see scipy.stats.normaltest)
continuum_chunkimage = True
continuum_chunkimage_startchannels = [0,32,64,96,128,160,192,224]
continuum_chunkimage_endchannels = [31,63,95,127,159,191,223,255]
continuum_chunkimage_imsize = 2049
continuum_chunkimage_cellsize = 4
continuum_chunkimage_minorcycle = 5
continuum_chunkimage_minorcycle_function = 'square'
continuum_chunkimage_c0 = 10.0
continuum_chunkimage_c1 = 5.0
continuum_chunkimage_drinit = 30
continuum_chunkimage_dr0 = 2.0
continuum_chunkimage_mindr = 5.0
continuum_chunkimage_nsigma = 5

[LINE]
line_splitdata = True
line_splitdata_chunkbandwidth = 0.02
line_splitdata_channelbandwidth = 0.000012
line_transfergains = True
line_subtract = True
line_subtract_mode = 'uvmodel'
line_subtract_mode_uvmodel_majorcycle_function = 'square'
line_subtract_mode_uvmodel_minorcycle_function = 'square'
line_subtract_mode_uvmodel_minorcycle = 5
line_subtract_mode_uvmodel_c0 = 10.0
line_subtract_mode_uvmodel_c1 = 5.0
line_subtract_mode_uvmodel_drinit = 25
line_subtract_mode_uvmodel_dr0 = 2.0
line_subtract_mode_uvmodel_nsigma = 30
line_subtract_mode_uvmodel_imsize = 513
line_subtract_mode_uvmodel_cellsize = 10
line_subtract_mode_uvmodel_minorcycle0_dr = 3.0
line_image = True
line_image_channels = '9650,9800' # Two comma seperated values as a string with the beginning and end channels, zero based
line_image_imsize = 2049
line_image_cellsize = 4
line_image_centre = ''
line_image_robust = -2
line_image_ratio_limit = 1.05
line_image_c0 = 10.0
line_image_c1 = 5.0
line_image_nsigma = 45
line_image_minorcycle0_dr = 5.0
line_image_dr0 = 2.0
line_image_restorbeam = ''
line_image_convolbeam = '30,30,0.0'

[MOSAIC]
mosaic_continuum_stack = True
mosaic_continuum_chunks = True
mosaic_line = False
mosaic_polarisation = False

[TRANSFER]
transfer_convert_lineuv2uvfits = True
